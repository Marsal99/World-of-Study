Itt van egy alap C# p√©lda, amely az OpenAI API seg√≠ts√©g√©vel elk√ºldi a felhaszn√°l√≥ √ºzenet√©t √©s visszakap egy v√°laszt.

Ehhez el≈ësz√∂r regisztr√°lnod kell az OpenAI-n√°l, √©s kell egy API-kulcs.

1Ô∏è‚É£ Telep√≠tsd az OpenAI API kliens√©t
C#-ban a legegyszer≈±bb, ha HttpClient-et haszn√°lsz, de van egy OpenAI.Net nev≈± NuGet csomag is, ami megk√∂nny√≠ti a dolgot.
Telep√≠tsd NuGet-b≈ël:

bash
M√°sol√°s
Szerkeszt√©s
dotnet add package OpenAI
Vagy a Visual Studio Package Manager Console-ban:

powershell
M√°sol√°s
Szerkeszt√©s
Install-Package OpenAI
2Ô∏è‚É£ K√©sz√≠ts egy egyszer≈± OpenAI API kliens oszt√°lyt
Ez az oszt√°ly fogja kezelni a kommunik√°ci√≥t az OpenAI szerver√©vel.

üîπ OpenAIClient.cs
csharp
M√°sol√°s
Szerkeszt√©s
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

public class OpenAIClient
{
    private readonly string apiKey;
    private readonly HttpClient httpClient;

    public OpenAIClient(string apiKey)
    {
        this.apiKey = apiKey;
        httpClient = new HttpClient();
    }

    public async Task<string> GetChatResponse(string userMessage)
    {
        var requestBody = new
        {
            model = "gpt-4",
            messages = new[]
            {
                new { role = "system", content = "Te egy seg√≠t≈ëk√©sz AI vagy egy oktat√°si j√°t√©kban." },
                new { role = "user", content = userMessage }
            },
            max_tokens = 100
        };

        var requestJson = JsonSerializer.Serialize(requestBody);
        var content = new StringContent(requestJson, Encoding.UTF8, "application/json");

        httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {apiKey}");

        var response = await httpClient.PostAsync("https://api.openai.com/v1/chat/completions", content);
        var responseJson = await response.Content.ReadAsStringAsync();

        using var doc = JsonDocument.Parse(responseJson);
        return doc.RootElement.GetProperty("choices")[0].GetProperty("message").GetProperty("content").GetString();
    }
}
3Ô∏è‚É£ Haszn√°lat a f≈ë programban
Most m√°r haszn√°lhatod az OpenAIClient oszt√°lyt a f≈ë programodban.

üîπ Program.cs
csharp
M√°sol√°s
Szerkeszt√©s
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        string apiKey = "IDE_√çRD_BE_AZ_OPENAI_API_KULCSODAT"; // üö® FONTOS: API kulcsodat itt add meg!
        var chatBot = new OpenAIClient(apiKey);

        Console.WriteLine("K√©rdezz valamit a mesters√©ges intelligenci√°t√≥l!");
        
        while (true)
        {
            Console.Write("Te: ");
            string userMessage = Console.ReadLine();

            if (userMessage.ToLower() == "exit")
                break;

            string response = await chatBot.GetChatResponse(userMessage);
            Console.WriteLine($"AI: {response}");
        }
    }
}
4Ô∏è‚É£ Fut√°s
Ford√≠tsd √©s futtasd a programot:
bash
M√°sol√°s
Szerkeszt√©s
dotnet run
√çrj be egy k√©rd√©st, √©s az AI v√°laszolni fog.
Ha "exit"-et √≠rsz, kil√©p a program.
Tov√°bbfejleszt√©si lehet≈ës√©gek
Ha ezt egy Unity j√°t√©kba akarod be√©p√≠teni, akkor a HttpClient-et aszinkron m√≥don kell megh√≠vnod egy Coroutine vagy egy async Task seg√≠ts√©g√©vel.
A v√°laszokat egy NPC sz√∂vegbubor√©k√°ban is megjelen√≠theted.
Ha offline kellene, egy saj√°t szab√°lyalap√∫ chatbotot √©p√≠thetsz el≈ëre meg√≠rt v√°laszokkal.
Ha k√©rd√©sed van vagy finom√≠tani szeretn√©d, sz√≥lj! üöÄ
